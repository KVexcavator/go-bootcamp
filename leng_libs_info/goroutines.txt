Горутины (goroutines) позволяют программам работать над несколькими задачами одновременно. Они координируют свою работу при помощи каналов, по которым могут отправлять данные друг другу и синхронизировать выполнение, чтобы одна горутина не опережала другую.
В Go конкурентно выполняемые задачи называются горутинами. В других языках программирования существует аналогичная концепция потоков, но горутины расходуют меньше компьютерной памяти, чем потоки, а также быстрее запускаются и останавливаются, а это означает, что вы можете запускать больше горутин одновременно.
Горутины обеспечивают возможность конкурентности: приостановки одной задачи для работы над другими задачами. А в других ситуациях они позволяют реализовать параллелизм: одновременную работу над несколькими задачами!

Для запуска новой горутины используется go-команда — обычный вызов функции или метода, перед которым находится ключевое слово go:
go myFunction()
go otherFunction("argument")
-----------------------------------------------------
! Все программы Go содержат по крайней мере одну горутину: ту, которая вызывает функцию main при запуске программы. Программы Go завершаются при остановке горутины main, даже если другие горутины еще не завершили свою работу.
-----------------------------------------------------
! горутины выполняются в разном порядке при каждом запуске программы
=====================================================
Пример конкурентного выполнения:
----
package main
import (
    "fmt"
    "time"
  )

// Функция, выполняемая как go-подпрограмма
func count() {
  for i := 0; i < 5; i++ {
    fmt.Println(i)
    time.Sleep(time.Millisecond * 1)
  }
}

func main() {
  // Вызов go-подпрограммы
  go count()

  time.Sleep(time.Millisecond * 2)
  fmt.Println("Hello World")
  time.Sleep(time.Millisecond * 5)
}
=====================================================
! в go-командах не могут использоваться возвращаемые значения функций, например, такой код не отработает:
func main(){
  ...
  size = go responseSize("https://example.com/")
  fmt.Println(size)
  ...
}
func responseSize(url string) int {
  ...
  return len(body)
}
Компилятор не позволяет получать возвращаемое значение из функции, вызванной в go-команде.

================================================
Канал - структура данных, используемая для передачи данных между горутинами
Каждый канал передает значения только заранее определенного типа

Каналы позволяют передавать значения из одной горутины в другую, и гарантируют, что отправляющая горутина отправила значение перед тем, как получающая горутина попытается его использовать.

Чтобы объявить переменную для хранения канала, используется ключевое слово chan с типом значений, которые будут передаваться каналом.
var myChannel chan float64
Фактическое сщздание канала
myChannel = make(chan float64)
или короткая запись
myChannel := make(chan float64)
Составные типы — такие, как сегменты, ассоциативные массивы и структуры, — могут передаваться как тип канала
type Page struct ...
pages := make(chan Page)

Для отправки значений по каналу используется оператор <-
myChannel <- 3.14
получения значений из каналов
<- myChannel
можно передавать
fmt.Println(<-myChannel)
или в переменную
receivedValue := <-myChannel
==========================================
Пример Передача переменных между go-подпрограммами
===
package main
import (
    "fmt"
    "time"
  )

// Канал для передачи целого значения
func printCount(c chan int) {
  num := 0
  for num >= 0 {
    // Ожидание целого значения
    num = <-c
    fmt.Print(num, " ")
  }
}
func main() {
  // Создание канала
  c := make(chan int)
  a := []int{8, 6, 7, 5, 3, 0, 9, -1}
  // Вызов сопрограммы
  go printCount(c)
  for _, v := range a {
    // Запись целого значения в канал
    c <- v
  }
  // Функция main приостанавливается перед завершением
  time.Sleep(time.Millisecond * 1)
  fmt.Println("End of main")
}
==============================================

------------------------------------------
Каналы также гарантируют, что отправляющая горутина отправила значение
Для этого каналы применяют блокировку — все дальнейшие операции в текущей горутине приостанавливаются.

Синхронзация
Операция отправки блокирует отправляющую горутину до того, как другая горутина выполнит операцию получения с тем же каналом.
И наоборот: операция получения блокирует получающую горутину до того, как другая горутина выполнит операцию отправки с тем же каналом.
