// При вызове recover во время нормального выполнения программы функция просто возвраща ет nil и больше ничего не делает, fmt.Println(recover()) вернет nil
// вызывать recover в одной функции с panic бессмысленно, потому что паника все равно продолжится
// Даже при панике все отложенные вызовы функций будут завершены. Таким образом, вызов recover можно разместить в отдельной функции и использовать defer при вызове этой функции перед кодом,в котором возникает паника.
package main

import "fmt"

// Вызывает recover и выводит fmt.Println(recover()) значение, переданное panic.
func calmDown() {
	p := recover()
	// утверждение, что фактическим обьуктом паника является интерфейс error
	err, ok := p.(error)
	if ok {
		fmt.Println(err.Error())
	}
}

// Значение panic("oh no") возвращено из recover.
func main() {
	defer calmDown()
	err := fmt.Errorf("there's an error")
	// вместо паники передается значение ошибки
	panic(err)
}
